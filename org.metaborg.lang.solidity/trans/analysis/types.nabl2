module analysis/types

imports
  signatures/types-sig
  signatures/vars-sig

signature
  sorts
    Type
  
  constructors
    //Numeric types
    IntT         : INT -> Type
    UIntT        : INT -> Type
    FixedT       : INT * INT -> Type
    UFixedT      : INT * INT -> Type
    
    //One word types
    BoolT        : Type
    AddressT     : Type
//    ByteT        : Type //byte == bytes1
    StringT      : Type
    
    //Byte arrays
    FBytesT      : INT -> Type
    DBytesT      : Type
    
    //Array types
    FArrayT      : Type * INT -> Type
    DArrayT      : Type -> Type
    
    //Function types
    FunctionT    : list(Type) * list(Type) -> Type // add VisibilityType
    FunctionModT : list(Type) -> Type
    
    //Mapping types
    MappingT     : Type * Type -> Type

    //User defined types
    EnumT        : Type
    EventT       : list(Type) -> Type
    StructT      : Type
    ContractT    : Type
    InterfaceT   : Type
    LibraryT     : Type
    BuiltInT     : Type
    
    //Named type
    NamedT       : occurrence * Type -> Type
    
    //Var type
    VarT         : Type
    
    //Void type (for functions with no return)
    VoidT        : Type
    
    //Simplified type
    IntTS        : Type
    UIntTS       : Type
    FBytesTS     : Type
    FixedTS      : Type
    UFixedTS     : Type
    FArrayTS     : Type -> Type
    NamedTS      : Type
    
    //More general types for constants
    NrT          : INT * INT -> Type
    FractT       : INT * INT * INT * INT -> Type
    StringLitT   : INT -> Type
    
    InvalidType  : Type
  
  namespaces
    //Something that can be referenced as a type.
    //TODO Add origin-like field to distinguish between enums, events, etc.?
    TypeReferrable { origin : occurrence }

rules
  //Simple types
  [[ BooleanType() ^ (s) : BoolT()    ]].
  [[ AddressType() ^ (s) : AddressT() ]].
  [[ StringType()  ^ (s) : StringT()  ]].

  //-----------------------------------------------------------------------------------------------
  //Numbers
  [[ IntType(x)  ^ (s) : ty ]] := ty == IntT(x).
  [[ UIntType(x) ^ (s) : ty ]] := ty == UIntT(x).
  [[ FixedType(MxN(m, n))  ^ (s) : ty ]] := ty == FixedT(m, n).
  [[ UFixedType(MxN(m, n)) ^ (s) : ty ]] := ty == UFixedT(m, n).
  
  //-----------------------------------------------------------------------------------------------
  //Byte arrays
  [[ FixedBytesArrayType(x)  ^ (s) : ty ]] := ty == FBytesT(x).
  [[ DynamicBytesArrayType() ^ (s) : ty ]] := ty == DBytesT().
  
  //-----------------------------------------------------------------------------------------------
  //Arrays
  [[ FixedArrayType(base, sizeExp) ^ (s) : ty ]] :=
    [[ base ^ (s) : baseTy ]],
    //TODO Determine size from expression!
    [[ sizeExp ^ (s) : sizeTy ]],
    //TODO Check if size is an int?
    ty == FArrayT(baseTy, 1).
  
  [[ DynamicArrayType(base)        ^ (s) : ty ]] :=
    [[ base ^ (s) : baseTy ]],
    ty == DArrayT(baseTy).
  
  //-----------------------------------------------------------------------------------------------
  //Functions
  [[ FunctionType(args, vis, stateMut, rets) ^ (s) : ty ]] :=
    Map1T [[ args ^ (s) : argTys ]],
    Map1T [[ rets ^ (s) : retTys ]],
    ty == FunctionT(argTys, retTys).
    //TODO Store  visibility and mutability
  
  //-----------------------------------------------------------------------------------------------
  //Mappings
  [[ MappingType(from, to) ^ (s) : ty ]] :=
    [[ from ^ (s) : fromTy ]],
    [[ to   ^ (s) : toTy   ]],
    ty == MappingT(fromTy, toTy).

  //-----------------------------------------------------------------------------------------------
  //User defined types
  [[ UserDefinedType(x) ^ (s) : tyRef ]] :=
    //TODO
    //Lookup the type
    TypeReferrable{x} -> s,
    TypeReferrable{x} |-> ref | error $[Cannot find any user defined type [x]] @x,
    ref : tyRef.
  
  //-----------------------------------------------------------------------------------------------
  //Var type
  [[ Var() ^ (s) : VarT() ]].
  
  //A reference to a type
  [[ TypeRef(name) ^ (s) : tyRef ]] :=
    TypeReferrable{name} -> s,
    TypeReferrable{name} |-> ref | error $[Unable to find [name]] @name,
    ref : tyRef | error @name.
  
  //A path reference to a type
  [[ TypeRef(ref, name) ^ (s) : tyRef ]] :=
    [[ ref ^ (s) : tyRefBase ]],
    tyRefBase == NamedT(occ, tyRefBaseBase) | error $[Unable to find [ref]] @name,
    
    occ ?=I=> occScope | error @name,
    
    new resolveScope,
    resolveScope -P-> occScope,
    
    TypeReferrable{name} -> resolveScope,
    TypeReferrable{name} |-> ref | error $[Unable to find [name]] @name,
    ref : tyRef | error @name.
  
  