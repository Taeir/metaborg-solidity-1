module codegen/util

imports
  signatures/ebc/-
  analysis/types

strategies
  /**
   * Repeats strategy s n times.
   * Fails if any of the applications fails.
   *
   * @param  strategy - the strategy to apply
   * @param  int      - the number of times to apply the strategy
   */
  do-n(s|n) = (<leq> (n, 0); id) <+ (s; n' := <subti> (n, 1); do-n(s|n'))

rules
  
  //utin8   = PUSH FF, AND
  //uint16  = PUSH FFFF, AND
  //uint24  = PUSH FFFFFF, AND
  //etc.
  
  //int8    = PUSH 0, SIGNEXTEND
  //int16   = PUSH 1, SIGNEXTEND
  //int24   = PUSH 2, SIGNEXTEND
  //etc.
  
  extend-to-32-bytes: BoolT() -> [
    ISZERO(),
    ISZERO()
  ]
  extend-to-32-bytes: IntT(256) -> []
  extend-to-32-bytes: IntT(n)   -> [
    PUSH(1, <divi> (n, 8)),
    SIGNEXTEND()
  ]
  extend-to-32-bytes: UIntT(256) -> []
  extend-to-32-bytes: UIntT(n)   -> [
    PUSH(n', <conc-strings> ("0x", <do-n(append-FF|n')> "") ),
    AND()
  ] where n' := <divi> (n, 8)
  
  append-FF: s -> <conc-strings> (s, "FF")
  
  /**
   * Creates a push instruction of the appropriate size (smallest length fitting the given number).
   */
  //TODO biginteger division instead of integer division
  create-push: nr    -> PUSH(<addi> (<divi> (nr, 256), 1), nr)
  //create-push: nrHex -> PUSH(<addHex> (<divHex> (nrHex, "0x100"), "0x1"), nrHex)